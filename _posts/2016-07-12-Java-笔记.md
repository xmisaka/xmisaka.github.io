---
layout: post
title: Java笔记：初始化与清理
tags:
- Java
categories: Java
description: 
---
##用构造器确保初始化

- **Q：为什么要使用构造器？**  
>可以假想为编写的每个类定义一个initialize()方法。该方法的名称提醒你在使用其对象之前，应首先调用initialize()。然而，这意味着用户必须去记得自己去调用此方法。在Java中，通过提供构造器，来确保每个对象都会得到初始化。

- **Q：如何命名这个方法？**
> 1. 这个名字不能与成员名称相冲突；
> 2. 必须让编译器知道应该调用哪个方法。  
Java中采用了与C++相同的方案：即构造器采用与类相同的名称。  

如果你写的类中没有构造器，则编译器会总动创建一个默认(无参)的构造器，以保证一定能够得到初始化。但是，如果已经定义了一个构造器（无论是否有参），编译器就不会自动创建默认构造器。所以当我们只定义了有参的构造器时，去调用默认的构造器就会得到一个编译错误。一个好的习惯就是，为每一个类都手工添加无参的构造器。

##方法重载

在日常生活中，相同的词可以表达多种不同的含义——他们被“重载”了。特别是含义之间的差别很小时，这种方式十分有用。比如说“洗衣服”包括，用洗衣粉洗衣服、用洗衣液洗衣服….如果每一个都定义一个方法的话就是：  
```
1. CleanWithPower(){};
2. CleanWIthWater(){};
```
如果还有许多其他的洗衣方式，就需要给每一个都命名，这样实在过于啰嗦，我们有时候根本不需要对所执行的动作做出明确的区分。我们只要表达洗衣服就可以了。
我们可以给予同样的名称，然后对其提供不同的参数类型或参数列表，来实现不同的动作。  
在Java中，构造器的名字由类名决定，就只能有一个构造器名。那么要想用多种方式创建一个对象就必须用到方法重载。  
方法重载，是以参数列表和参数类型来区分的。对于基本类型的重载，基本类型能从一个“较小”的类型自动提升到一个“较大”的类型。  
有时候我们只是为了想要方法产生的副作用而调用方法，而不是为了返回值，比如构造方法。所以我们可能直接有以下代码：`f()`;所以不能根据返回值类型来区分重载方法，因为Java无法判断该调用哪一个`f()`。

##this关键字
如果只有一个peel()方法，它如何知道是被a调用还是被b所调用呢?
```java
1 ﻿class Banana{void peel(int i){ /* ... */}}
2 
3 public class BananaPeel{
4     Banana static void main(String[] args){
5         Banana a = new Banana(),
6              b = new Banana();
7         a.peel(1);
8         b.peel(2);
9     }
10 }
```

