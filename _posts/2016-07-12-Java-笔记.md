---
layout: post
title: Java笔记：初始化与清理
tags:
- Java
categories: Java
description: 随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主要原因之一。初始化和清理正式涉及安全的两个问题。
---
##用构造器确保初始化

- **Q：为什么要使用构造器？**  
>可以假想为编写的每个类定义一个initialize()方法。该方法的名称提醒你在使用其对象之前，应首先调用initialize()。然而，这意味着用户必须去记得自己去调用此方法。在Java中，通过提供构造器，来确保每个对象都会得到初始化。

- **Q：如何命名这个方法？**
> 1. 这个名字不能与成员名称相冲突；
> 2. 必须让编译器知道应该调用哪个方法。  
Java中采用了与C++相同的方案：即构造器采用与类相同的名称。  

如果你写的类中没有构造器，则编译器会总动创建一个默认(无参)的构造器，以保证一定能够得到初始化。但是，如果已经定义了一个构造器（无论是否有参），编译器就不会自动创建默认构造器。所以当我们只定义了有参的构造器时，去调用默认的构造器就会得到一个编译错误。一个好的习惯就是，为每一个类都手工添加无参的构造器。

##方法重载

在日常生活中，相同的词可以表达多种不同的含义——他们被“重载”了。特别是含义之间的差别很小时，这种方式十分有用。比如说“洗衣服”包括，用洗衣粉洗衣服、用洗衣液洗衣服….如果每一个都定义一个方法的话就是：  
```
1. CleanWithPower(){};
2. CleanWIthWater(){};
```
如果还有许多其他的洗衣方式，就需要给每一个都命名，这样实在过于啰嗦，我们有时候根本不需要对所执行的动作做出明确的区分。我们只要表达洗衣服就可以了。
我们可以给予同样的名称，然后对其提供不同的参数类型或参数列表，来实现不同的动作。  
在Java中，构造器的名字由类名决定，就只能有一个构造器名。那么要想用多种方式创建一个对象就必须用到方法重载。  
方法重载，是以参数列表和参数类型来区分的。对于基本类型的重载，基本类型能从一个“较小”的类型自动提升到一个“较大”的类型。  
有时候我们只是为了想要方法产生的副作用而调用方法，而不是为了返回值，比如构造方法。所以我们可能直接有以下代码：`f()`;所以不能根据返回值类型来区分重载方法，因为Java无法判断该调用哪一个`f()`。

##this关键字
如果只有一个peel()方法，它如何知道是被a调用还是被b所调用呢?
```java
1 ﻿class Banana{void peel(int i){ /* ... */}}
2 
3 public class BananaPeel{
4     Banana static void main(String[] args){
5         Banana a = new Banana(),
6              b = new Banana();
7         a.peel(1);
8         b.peel(2);
9     }
10 }
```
为了能用简便、面向对象的语法来编写代码——即“发送消息给对象”，编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给方法。所以上述两个方法就变成了这样：`Banana.peel(a, 1); Banana.peel(b, 2);`这是内部的表示形式。我们并不能这样书写代码。  
假设你希望在方法的内部获得对当前对象的引用。由于这个引用是编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：`this`。this关键字只能在方法的内部使用，表示对`调用方法的那个对象`的引用。常常使用`return this;`来返回对当前对象的引用。  
通常写`this`的时候，都是指`这个对象`或者`当前对象`，而且它本身表示对当前对象的引用。在构造器中，如果为`this`添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用；这样，调用其他构造器就有了直接的途径。  
**在构造器中，尽管可以用`this`调用一个构造器，但却不能调用两个。此外，必须将构造器调用置于最起始处，否则编译出错。**

##成员初始化
Java尽力保证：所有变量的使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误来贯彻这种保证。  
在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，他们仍旧会在任何方法（包括构造器）被调用之前得到初始化。

##清理：终结处理和垃圾回收
在C++中，对象一定会被销毁（如果程序中没有缺陷的话）；而Java里的对象却并非总是被垃圾回收。
>1. 对象可能不被垃圾回收；
>2. 垃圾回收并不等于“析构”；
>3. 垃圾回收只与内存有关。  

Java允许在类中定义一个名为`finalize()`的方法。它的工作原理"假定"是这样的：一旦垃圾回收器准备好释放占用的存储空间，将首先调用其`finalize()`方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。但是，就算手工调用`finalize()`方法，也并不能确保垃圾得到回收，垃圾回收只与内存有关。
