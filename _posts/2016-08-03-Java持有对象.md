---
layout: post
title: Java笔记：随机数
tags:
- Java
categories: Java
description: 如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序。
---
通常，程序总是根据运行时踩知道的某些条件去创建对象。在此之前，不知道所需对象的数量，甚至不知道确切的类型。为解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象。所以就不能依靠创建命名的引用来持有每一个对象，因为你不知道实际上会需要多少这样的引用。  

##Java容器类概述
Java容器类都可以自动地调整自己的尺寸。  
Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念。  
>1. Collection。一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。  
2. Map。一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，因此在某种意义上讲，它将数字与对象关联在了一起。映射表允许我们使用另一个对象来查找某一个对象，它也被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起。

尽管并非总是这样，但是在理想的情况下，你编写的大部分代码都是在爱与这些接口打交道，并且你唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个`List`:
>List<Apple> apples = new ArrayList<Apple>();    

使用接口的目的在于如果你决定去修改你的实现，你所需的只是在创建处修改它，就像下面这这样：
>List<Apple> apples = new LinkedList<Apple>();

因此，你应该创建一个具体类的对象，将其转型为对相应的接口，然后在其余代码中都使用这个接口。  这种方式并非总能奏效，因为某些类具有额外的功能。  

##Collection接口中的方法
```java
boolean add(E e)
boolean addAll(Collection<? extends E> c)
void clear()
boolean contains(Object o)
boolean containsAll(Collection<?> c)
boolean equals(Object o)
int hashCode()
boolean isEmpty()
Iterator<E> iterator()
boolean remove(Object o)
boolean removeAll(Collection<?> c)
boolean retainAll(Collection<?> c)
int size()
Object[] toArray()
<T> T[] toArray(T[] a)
```

##List
*List*承诺可以将元素维护在特定的序列中。List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。  
有两种类型的List：  

+ ArrayList，使用数组实现，它鲳鱼随机访问元素，但是在List的中间插入和移除元素时较慢。

+ LinkedList，使用链表实现，在List中间插入和删除代价较低，提供了优化的顺序访问。在随机访问方面相对比较慢，但它的特性集比ArrayList更大。  

LinkedList能够实现栈和队列的所有功能。  

+ 其中栈方法有：push()、peek()、pop()、empty()  

+ 队列方法有：offer()、poll()/remove()、peek()/element()、empty()


##迭代器
迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器通常被称为轻量级对象：创建它的代价小。因此，可以经常见到对迭代器有些奇怪的限；例如，Java的Iterator只能单向移动，这个Iterator只能用来：  
>1. 使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。  
2. 使用next()获得序列中的下一个元素。  
3. 使用hasNext()检查序列中是否还有元素。  
4. 使用remove()将迭代器新近返回的元素删除。这意味着在调用remove()之前必须先调用next()。  

使用方法如下：
```java
1 ﻿public class SimpleIteration{
2     public static void main(String[] args){
3         List<Integer> lists = new ArrayList<Integer>();
4         for(int I = 0; i < 10; i++){
5             lists.add(i);
6         }
7         Iterator<Integer> it = lists.iterator();
8         while(it.hasNext()){
9             int i = it.next();
10             System.out.println(p.id() + ":" + " ");
11         }
12         // A simple approach, when possible:
13         for(int i : lists){
14             System.out.println(p.id() + ":" + " ");
15         }
16         // An Iterator can also remove elements；
17         it = lists.iterator();
18         for(int I = 0; i < 8; i++){
19             it.next();
20             it.remove();
21         } 
22     }
23 }

```

ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。  
你可以通过调用ListIterator()方法产生一个指向List开始出的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。  
使用例子如下：  
```java
1 ﻿public class ListIteration {
2     public static void main(String[] args){
3         List<String> lists = new ArrayList<String>();
4         lists.add("one");
5         lists.add("two");
6         lists.add("three");
7         lists.add("four");
8         lists.add("five");
9         lists.add("six");
10         lists.add("seven");
11         lists.add("eight");
12         lists.add("nine");
13         lists.add("ten");
14         
15         ListIterator<String> it = lists.listIterator(1);
16         while(it.hasNext()){
17             System.out.print(it.next() + ", " + it.nextIndex() + ", " + it.previousIndex() + ";");
18         }
19         System.out.println();
20     }
21 }
```

